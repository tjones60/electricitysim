# -*- coding: utf-8 -*-
"""369data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AqjvtcglBY2bsm1Sh-MX_Sdt_53KLByy
"""

import pandas as pd
import numpy as np
# from google.colab import drive
# drive.mount('/content/drive')

# ADD ACTUAL FILE TO DRIVE; PARSE CONFIG
# WHEN DOWNLOADING AS .PY, CHANGE TO READING FROM CORRECT DIRECTORY

# import data
directory = 'https://github.com/tjones60/electricitysim/blob/main/data/'

df_curtail = pd.read_csv(directory + 'curtailment-ca-2019.csv?raw=true',
                         names=['date','hour','interval','wind_curtailment','solar_curtailment'],
            index_col=[0,1,2])

# df_curtail.head()
# print(len(df_curtail))
# df_curtail.dtypes

# demand same as load
df_production = pd.read_csv(directory + 'production-ca-2019.csv?raw=true',
                            names=['date','hour','interval','demand','solar','wind',
                                  'net_load','renewables','nuclear','large_hydro',
                                  'imports','generation','thermal','load_less'])
df_production['date'] = df_production['date'].str[:10]

# df_production.head()
# print(len(df_production))
# df_production.dtypes

df_final = df_production.join(df_curtail, on=['date', 'hour', 'interval'], how='left')
# print(len(df_final))
# print(df_final['wind_curtailment'].isna().sum())
df_final.fillna(0, inplace=True)
# print(df_final['wind_curtailment'].isna().sum())
# df_final.head()

df_final['wind'] += df_final['wind_curtailment']
df_final['solar'] += df_final['solar_curtailment']
# IF MISSING DATA, USE 5 MINUTES ANYWAY
df_final['minute_difference'] = 5.0
df_final['time_factor'] = 3600.0 / (df_final['minute_difference'] * 60)
# subsetting columns; if we need to take other energy into account, change the subset
#df_final = df_final[df_final.columns[3:8]]
print(sum(df_final.memory_usage()))
df_final.head()

# AGREE ON FILE CONVENTION AND CHANGE TO READ VALUES FROM FILE

def generate_simulation_inputs(file):
  df_configs = pd.DataFrame(columns=["nuclear", "solar_scale_factor", "wind_scale_factor",
                                   "min_soc", "max_soc", "initial_soc", 
                                   "battery_capacity"])
  
  nuclear_samples = 10
  solar_samples = 5
  wind_samples = 5
  battery_samples = 10

  # df_configs["nuclear"] = np.repeat(np.linspace(1000, 4000, nuclear_samples), 
  #                                   solar_samples*wind_samples*battery_samples)
  # for i in range(0, len(df_configs), 250):
  #   df_configs.loc[i:i+249, 'solar_scale_factor'] = np.repeat(np.linspace(1,2,solar_samples), 
  #                                              wind_samples*battery_samples)
  # for i in range(0, len(df_configs), 50):
  #   df_configs.loc[i:i+49, 'wind_scale_factor'] = np.repeat(np.linspace(1, 2, wind_samples), battery_samples)
  # for i in range(0, len(df_configs), 10):
  #   df_configs.loc[i:i+9, 'battery_capacity'] = np.linspace(1000, 2000, battery_samples)
  # df_configs.head(100)

  df_configs["nuclear"] = np.repeat(np.linspace(1000, 4000, nuclear_samples), 
                                    solar_samples*wind_samples*battery_samples)
  solar = np.repeat(np.linspace(1,2,solar_samples), wind_samples*battery_samples)
  solar = list(solar) * (len(df_configs)//len(solar))
  df_configs['solar_scale_factor'] = solar
  wind = np.repeat(np.linspace(1, 2, wind_samples), battery_samples)
  wind = list(wind) * (len(df_configs)//len(wind))
  df_configs['wind_scale_factor'] = wind
  battery = np.linspace(1000, 2000, battery_samples)
  battery = list(battery) * (len(df_configs)//len(battery))
  df_configs['battery_capacity'] = battery

  if len(df_configs) != len(df_configs.drop_duplicates()):
    raise ValueError

  # implement functionality for changing this later
  df_configs['min_soc'] = 0.0
  df_configs['max_soc'] = 1.0
  df_configs['initial_soc'] = 0.5

  df_configs["current_value"] = df_configs["battery_capacity"] * df_configs["initial_soc"]
  df_configs["min_value"] = df_configs["battery_capacity"] * df_configs["min_soc"]
  df_configs["max_value"] = df_configs["battery_capacity"] * df_configs["max_soc"]

  display(df_configs)

generate_simulation_inputs("provide file name here")

# RUN PYTHON SIMULAITON PROCESS WITH VALUE FROM EACH ROW FOR EACH ROW
# GET OUTPUT; SAVE IN THE DATAFRAME

def run_single_simulation(input_dict, input_df, export=False):
  # might need to import pandas in here; not sure if importing it works across the whole cluster
  # maybe need to make a copy of the dataframe
  df_final = input_df#.copy()

  df_final['solar'] *= input_dict['solar_scale_factor']
  df_final['wind'] *= input_dict['wind_scale_factor']
  # could get rid of followig step later
  df_final['nuclear'] = input_dict['nuclear']
  df_final['clean'] = df_final['nuclear'] + df_final['solar'] + df_final['wind']
  df_final['net'] = df_final['clean'] - df_final['demand']

  current_value = input_dict['battery_capacity'] * input_dict['initial_soc']
  min_value = input_dict['battery_capacity'] * input_dict['min_soc']
  max_value = input_dict['battery_capacity'] * input_dict['max_soc']

  # MUST use a loop (or apply function, but that's a loop anyway)
  stored = []
  battery = []
  gas = []
  curtailed = []
  soc = []
  net = df_final['net'].array
  #time_factor = df_final['time_factor'].array
  time_factor = 5 # simulation advances at constant 5 minute intervals

  for i in range(len(df_final)):
    temp = current_value + net[i] / time_factor

    if temp < min_value:
      stored.append(min_value)
      battery.append((current_value - min_value) * time_factor)
      gas.append((min_value - current_value) * time_factor - net[i])
      curtailed.append(0.0)
    elif temp > max_value:
      stored.append(max_value)
      battery.append((current_value - max_value) * time_factor)
      gas.append(0.0)
      curtailed.append(net[i] - (max_value - current_value) * time_factor)
    else:
      stored.append(current_value + net[i] / time_factor)
      battery.append(-net[i])
      gas.append(0.0)
      curtailed.append(0.0)

    if battery_capacity != 0:
      soc.append(stored[i] / battery_capacity)
    else:
      soc.append(0.0)


    current_value = stored[i]

  df_final['gas'] = pd.Series(gas)
  df_final['curtailed'] = pd.Series(curtailed)
  if export is True:
    df_final['stored'] = pd.Series(stored)
    df_final['battery'] = pd.Series(battery)
    df_final['SOC'] = pd.Series(soc)
    # need to compute path - could just hash string representation of input_dict but need better way
    df_final.to_json(path, orient="index")

  total_demand = sum(df_final['demand']) / time_factor
  total_clean = sum(df_final['clean']) / time_factor
  total_gas = sum(df_final['gas']) / time_factor
  total_curtailed = sum(df_final['curtailed']) / time_factor

  result = {"% Clean":(1.0 - total_gas / total_demand) * 100,
            "% Curtailed":(total_curtailed / total_demand) * 100,
            "Total Demand":total_demand,
            "Total Clean":total_clean,
            "Total Gas":total_gas,
            "Total Curtailed":total_curtailed}

  # maybe need garbage collection command
  return result

# import_config
# hardcoded values from config file, but should read data from file after mountaing on drive

#Source

nuclear = 4000
solar_scale_factor = 1.0
wind_scale_factor = 1.0

#Battery

min_soc = 0.0
max_soc = 1.0
initial_soc = 0.5
battery_capacity = 1000

current_value = battery_capacity * initial_soc
min_value = battery_capacity * min_soc
max_value = battery_capacity * max_soc

df_final['nuclear'] = nuclear
df_final.tail()

df_final['solar'] *= solar_scale_factor
df_final['wind'] *= wind_scale_factor
df_final['clean'] = df_final['nuclear'] + df_final['solar'] + df_final['wind']
df_final['net'] = df_final['clean'] - df_final['demand']

# MUST use a loop (or apply function, but that's a loop anyway)
stored = []
battery = []
gas = []
curtailed = []
soc = []
net = df_final['net'].array
time_factor = df_final['time_factor'].array

for i in range(len(df_final)):
  temp = current_value + net[i] / time_factor[i]

  if temp < min_value:
    stored.append(min_value)
    battery.append((current_value - min_value) * time_factor[i])
    gas.append((min_value - current_value) * time_factor[i] - net[i])
    curtailed.append(0.0)
  elif temp > max_value:
    stored.append(max_value)
    battery.append((current_value - max_value) * time_factor[i])
    gas.append(0.0)
    curtailed.append(net[i] - (max_value - current_value) * time_factor[i])
  else:
    stored.append(current_value + net[i] / time_factor[i])
    battery.append(-net[i])
    gas.append(0.0)
    curtailed.append(0.0)

  if battery_capacity != 0:
    soc.append(stored[i] / battery_capacity)
  else:
    soc.append(0.0)


  current_value = stored[i]

df_final['stored'] = pd.Series(stored)
df_final['battery'] = pd.Series(battery)
df_final['gas'] = pd.Series(gas)
df_final['curtailed'] = pd.Series(curtailed)
df_final['SOC'] = pd.Series(soc)

total_demand = sum(df_final['demand'] / df_final['time_factor'])
total_clean = sum(df_final['clean'] / df_final['time_factor'])
total_gas = sum(df_final['gas'] / df_final['time_factor'])
total_curtailed = sum(df_final['curtailed'] / df_final['time_factor'])

result = [(1.0 - total_gas / total_demand) * 100, (total_curtailed / total_demand) * 100,\
  total_demand, total_clean, total_gas, total_curtailed]
print("% Clean % Curtailed Total Demand Total Clean Total Gas Total Curtailed<br>")
print(["{:.2f}".format(x) for x in result])

df_final
# export this using df_final.to_csv